<!DOCTYPE html><html lang="en-us"><head><meta charset="utf-8"><title>Home</title><base href="/spring26/labs/lab10/"><meta content="width=device-width, initial-scale=1" name="viewport"><style>@font-face {
    font-family: "Tex Gyre Heros";
    src: url("/spring26/assets/font/tex-gyre-heros/texgyreheros-regular.otf") format("opentype");
    font-weight: regular;
    font-style: regular;
}
@font-face {
    font-family: "Tex Gyre Heros";
    src: url("/spring26/assets/font/tex-gyre-heros/texgyreheros-bold.otf") format("opentype");
    font-weight: bold;
    font-style: regular;
}
@font-face {
    font-family: "Tex Gyre Heros";
    src: url("/spring26/assets/font/tex-gyre-heros/texgyreheros-italic.otf") format("opentype");
    font-weight: regular;
    font-style: italic;
}
@font-face {
    font-family: "Tex Gyre Heros";
    src: url("/spring26/assets/font/tex-gyre-heros/texgyreheros-bolditalic.otf") format("opentype");
    font-weight: bold;
    font-style: italic;
}</style><link href="/spring26/assets/main.css" rel="stylesheet">
<link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css" integrity="sha384-wcIxkf4k558AjM3Yz3BBFQUbk/zgIYC2R0QpeeYb+TwlBVMrlgLqwRjRtGZiK7ww" rel="stylesheet">
<link href="/spring26/assets/favicon.png" rel="icon" type="image/png">
</head>

<body>
<header><nav>
<h1><a href="/spring26/">Home</a></h1>
<p><a href="/spring26/calendar">Calendar</a></p>
<p><a href="/spring26/labs">Labs</a></p>
<p><a href="/spring26/lectures">Lectures</a></p>
<p><a href="/spring26/syllabus">Syllabus</a></p>
<p><a href="/spring26/resources">Resources</a></p>
<p><a href="/spring26/contact">Contact</a></p>
<p><a href="/spring26/piazza">Piazza</a></p>
</nav></header>

<main>
<h1>Lab 13: NanoGPT</h1>

https://github.com/stanford-cs149/cs149gpt/

<h2>Prologue: Logistics</h2>
<h3>Due Dates</h3>
<p>For this lab, you’ll be turning in the following deliverables:</p>
<ul>
<li>
<p><strong>Checkpoint</strong>: Due Friday, February 14, 11:59 pm. 
    Submit your completed code in XXX, your responses to Questions XXX, and a discussion of your progress on Part 1.</p>
</li>
<li>
<p><strong>Final Submission</strong>: Due Friday, November 21, 11:59 pm. 
    Submit your completed code for all parts of the lab, 
    as well as a PDF writeup containing your answers for Question XXX of the final writeup.</p>
</li>
</ul>

<h3>Starter Code</h3>
<p>You can get the starter code for this lab by cloning the <a href="https://github.com/accelerated-computing-class/lab13">lab
repository</a>:</p>
<pre><span class="highlight-source highlight-shell highlight-bash"><span class="highlight-meta highlight-function-call highlight-shell"><span class="highlight-variable highlight-function highlight-shell">git</span></span><span class="highlight-meta highlight-function-call highlight-arguments highlight-shell"> clone git@github.com:accelerated-computing-class/lab13.git</span>
</span></pre>

<h3>Goals for This Lab</h3>

<p>
In this assignment, you will implement and optimize the key components of a transformer-based deep neural network that synthesizes Shakespeare text. 
While the DNN you will work with is a fairly small model, the basic components are the same as those in large-language models (LLMs) such as ChatGPT.
Specifically, you will implement the attention layer in C++, focusing on optimizations that improve arithmetic intensity, reduce memory footprint, 
and leverage multi-core and SIMD parallelism on the CPU. Your implementation will be used inside a complete 
<a href="https://github.com/karpathy/nanoGPT">NanoGPT</a> model, which you will run to generate Shakespeare-like text.
</p>

<p>This assignment will:</p>
<ul>
  <li>Give you experience with low-level DNN layer implementation—i.e., the “guts” of vendor libraries like NVIDIA CuDNN or Intel OneAPI.</li>
  <li>Show the value of locality-preserving optimizations such as loop blocking and loop fusion.</li>
</ul>

<h2>Environment Setup</h2>

<p>We will provide you with SSH access to a cluster of shared machines for testing your code for this assignment. (We are not using AWS Lightsail like we did in Programming Assignment 3). You will directly log into these machines via ssh. Details on how to access the cluster will be provided in an Ed post.</p>

<p>To get started, clone the repo from github:</p>

<pre><code>git clone https://github.com/stanford-cs149/cs149gpt.git
</code></pre>

<p>Run the command below to run inference using a model trained by the CS149 staff. You will see some randomly generated Shakespeare text.</p>

<pre><code>python3 gpt149.py part0 --inference -m shakes128
</code></pre>

<p>Note that the first time you run the program, it will perform a compilation step that may take a few seconds, you'll see the text <code>Compiling code into a PyTorch module...</code>. <br><br>
After this is complete, you'll see some text that begins something like this:</p>

<pre><code>Running inference using dnn model shakes128
number of parameters: 0.80M
Loading meta from data/shakespeare_char/meta.pkl...

BOTtaps along my lord.

DUKE OF AUMERLE:
The this is needs! Camillo, put I will make be strong.

QUEEN MARGARET:
My lord, yet t
-------------------------------------------------------------
CAMILLO:
The shadows men sweet thy will burn comes.

FLORIZEL:
But of appear, good from thy heart
As I be come of repeal of a w
-------------------------------------------------------------
</code></pre>

<p>Sure, NanoGPT's output may not be literary excellence, but it is still pretty neat! What you see on screen is the output of the standard PyTorch implementation of NanoGPT. Feel free to change to larger sequence lengths by changing the <code>-m</code> parameter to larger models like <code>shakes256</code>, <code>shakes1024</code>, or <code>shakes2048</code>. You'll see the performance of NanoGPT token generation slow considerably with the bigger models.</p>

<h3>My Compilation Hangs</h3>

<p>Some students have experienced issues when their compilation randomly starts hanging even though it was working before. When Python JIT compiles your code, it uses locks so multiple threads can compile it as once for efficiency. If you ever compile your code and it hangs, it means that for some reason Python thinks that the lock to your file is held. In order to fix this you can run:</p>

<pre><code>rm ~/.cache/torch_extensions/py310_cpu/custom_module/lock
</code></pre>

<h2>An Attention Module</h2>

<p>The NanoGPT module you are executing in this assignment is a sequence-to-sequence model. The input is a sequence of words, such as the phrase <em>"The course of true love never did run smooth"</em>. And the output of the model is a new sequence of words that is likely to follow the input, as determined by a model that has been trained on a large corpus of Shakespeare text. For example, given the prefix above, the output of the model might be <em>"whispered cs149 students whilst coding on assignments"</em>.</p>

<p>The NanoGPT model uses a popular DNN module called a <em>transformer</em>, and a key component of a transformer module is a block called the <em>attention mechanism</em>. In this assignment your job is to implement the attention mechanism. You will begin with a simple sequential implementation of attention, and then over the course of the assignment we'll take you through the process of adding optimizations like loop blocking, loop fusion, and basic parallelization.</p>

<p>In this section, we will describe the math of the attention mechanism (that you are supposed to compute). You may refer to <a href="https://gfxcourses.stanford.edu/cs149/fall23/lecture/dnneval/slide_52">Slide 52 of Lecture 10</a> for a visual representation to follow along with. To students that seek more intuition for <em>why</em> an attention mechanism is what it is, we refer you to the many online tutorials about this popular DNN architecture such as:</p>

<ul>
  <li><a href="https://ai.stackexchange.com/questions/21389/what-is-the-intuition-behind-the-attention-mechanism">What is the intuition behind the attention mechanism?</a></li>
  <li><a href="https://builtin.com/artificial-intelligence/transformer-neural-network">Transformer Neural Networks: A Step-by-Step Breakdown</a></li>
  <li><a href="https://towardsdatascience.com/transformers-141e32e69591">How Transformers Work</a></li>
</ul>

<p>The attention mechanism takes as input three matrices <code>Q</code>, <code>K</code>, and <code>V</code>, referred to as "query", "key", and "value" vectors. Each of these matrices are <code>N × d</code> in size. <code>N</code> is the number of tokens (words) in the input sequence, so each row in these matrices is a length-<code>d</code> vector containing an embedding (a neural code) for one of the input words. In other words, <code>Q</code>, <code>K</code>, and <code>V</code> all contain different <code>d</code>-dimensional embeddings of the input tokens.</p>

<p><strong>Important Caveat:</strong> To increase the efficiency and expressive power of the model, this attention module is typically run multiple times in parallel, due to there being multiple attention heads and multiple inputs in a batch. Understanding exactly why this is the case is not important, but just know that, in your implementation, these matrices will appear as <strong>4D</strong> tensors, where you will just be concerned with two of the four dimensions (corresponding to the <code>N × d</code> size.)</p>

<p>The first step of an attention module is to compute all pairs of interactions between the words. This is done by multiplying the query matrix <code>Q</code> against the key matrix <code>K</code> to compute:</p>

<p><strong>$$S = QK^T.$$</strong></p>

<p>The next computation is a <a href="https://machinelearningmastery.com/softmax-activation-function-with-python/">softmax operation</a> performed per-row of <code>S</code>. The softmax produces normalized probabilities per row.</p>

<p>For each row of the matrix, the softmax operation performs the following computation. Note that we give you the math for computing a softmax on a 1D vector <code>X</code>. You'll need to perform this math for each row of the matrix <code>S</code> above.</p>

<p><strong>$$\text{softmax}(x) = \frac{\mathbf{f}(x)}{l(x)}$$</strong></p>

<p>where</p>

<p><strong>$$\mathbf f(x) = 
\begin{bmatrix}
e^{x_1} & e^{x_2} & \cdots & e^{x_N}
\end{bmatrix}
\qquad \text{and} \qquad
l(x) = \sum_{i=1}^N f(x)_i.$$</strong></p>

<p>Note that the math above differs from the equation you saw in lecture in that <code>max(x)</code> is not subtracted from the numerators. The version of the math in lecture is what's used in practice for numerical stability, but in this assignment you can just use the math above. (It's a lot easier to implement FlashAttention later in the assignment if you use the math above.) For the ambitious, if you wish to use the version from lecture, feel free... you may see differences in "correctness checking".)</p>

<p>This yields a matrix of attention weights <code>P</code>, where:</p>

<p><strong>$$P = \texttt{softmax}(\texttt{each row of } S).$$</strong></p>

<p>Finally, the attention weights are used to aggregate a set of learned <strong>value</strong> vectors, which are provided as a matrix <code>V</code> of shape <code>N × d</code>, to produce a final output <code>O</code>:</p>

<p><strong>$$O = PV.$$</strong></p>

<p>In summary, the attention layer consists of an expensive matrix multiply, followed by a softmax layer, followed by one more matrix multiply. These three components will be the bulk of your implementation — read on for the details!</p>

<h2>Warm-Up: Accessing Tensors (3 Points)</h2>
<p>
Tensors are a data abstraction used in Pytorch. Although the name seems a bit intimidating, they are nothing more than multi-dimensional arrays. By abstracting these multi-dimensional arrays into a tensor datatype, the average PyTorch programmer no longer has to worry about how internals such as accessing a value or matrix multiplication work. Furthermore, Pytorch's tensors allow for easy GPU portability so that they can be run on specialized hardware, like Tensor cores. However, for this assignment we will be using CPU only, and instead of working with tensor datatypes we want you to work with a datatype you are all familiar with: C++ vectors.
</p>

<p>
A central key to understanding tensors is to know how to access them. This is why for the warm-up we want you to write accessors for a 4D tensor. For Parts 1-4, we have taken the liberty of providing you with a function called <code>formatTensor</code> that transforms Tensors into C++ vectors. This provides you with a contiguous memory layout for a tensor's values, similar to how Pytorch stores tensor data. For Parts 1-4, we have also taken the liberty of transforming the output vector back into a tensor for you.
</p>

<h3>Step 1: Understand a 2D Accessor</h3>
<p>
You should be relatively familiar with how to flatten a 2D array after Assignment 3. Your first job will be to understand how we can access an element of a multidimensional array, which is really just stored as a flattened 1D buffer in memory. We have given you example accessors for reading and writing to a 2D array. You will find them at the top of <code>module.cpp</code> under the names <code>twoDimRead</code> and <code>twoDimWrite</code>. The given 2D accessors will show you how we can access an arbitrary element <code>(i, j)</code> within this flattened array. <strong>Note that the formula is as follows: For any given element (i, j) within an array, you may access it using [i * number_of_columns + j].</strong>
</p>

<h3>Step 2: Implement a 4D Accessor</h3>
<p>
In our LLM model, our arrays are 4D, so we will actually need a 4D accessor to access its elements! Now, extend the concepts behind accessing a 2D tensor so that you can access a 4D tensor. Your job for Step 1 is to implement the functions <code>fourDimRead</code> and <code>fourDimWrite</code> in the file <code>module.cpp</code>.
</p>

<h3>Testing:</h3>
<p>Run the following command to test your 4D accessor:</p>

<pre><code>python3 gpt149.py 4Daccess
</code></pre>

<p>
When running the test, if you have implemented your accessors correctly, the expected and result values should be the same, resulting in an output like the one below.
</p>

<pre><code>Expected: 0.0006
Result: 0.0006
</code></pre>

<h3>What to submit</h3>
<ul>
  <li>Implement <code>fourDimRead</code> and <code>fourDimWrite</code> in the file <code>module.cpp</code>.</li>
  <li>
    Next, answer the following question in your writeup:
    <ul>
      <li>Briefly describe how a 4D tensor/array is laid out in memory. Why do you think this convention was chosen and how does it leverage hardware?</li>
    </ul>
  </li>
</ul>

<h2>Part 1: A Simple (But Not So Efficient) Implementation of Attention (10 Points)</h2>

<p>
Now that you have your accessors, it's time to start working on your custom attention layer. As the first step in this assignment, you will be implementing a serial attention layer in C++ with no optimizations. In <code>myNaiveAttention</code>, we have provided you with two examples. The first demonstrates how to fill a 4D tensor with 0's and the second demonstrates how to fill a 2D tensor with 0's. Extend these concepts such that you are able to implement attention. You should:
</p>

<pre><code>1) For each Batch:
2) For each Head:
    a) Loop through Q and K and multiply Q with K^t, storing the result in QK^t. 
       QK^t is preallocated for you, and passed as an arg to myNaiveAttention. 
       (You should not have to allocate any pytorch tensors for any part of this assignment)
       
       Note that after indexing the batch and head, you will be left with 2D matrices 
       of shape (N, d) for Q and K. Also note that the dimensions of K are (N, d) and 
       the dimensions of the K^t that you want are (d, N). Rather than transposing K^t, how
       can you multiply Q and K in such an order that the result is QK^t? Think about how
       you can reorder your `for` loops from traditional matrix multiplication.

    b) After you have achieved QK^t -- which should have shape (N, N) -- you should loop 
       through each row. For each row, you should get the exponential of each row element,
       which you can get using the C++ inbuilt `exp` function. Now, divide each of these 
       resulting exponentials by the sum of all exponentials in its row and then store it back into QK^t. 

    c) Finally, you should matrix multiply QK^t with V and store the result into O. 
       Notice, much like Q and K, after you index the batch and head V and O will
       be of shape (N, d). Therefore, after you multiply QK^t (N, N) with V (N, d),
       you can simply store the resulting shape (N, d) back into O.
</code></pre>

<h3>Testing</h3>

<p>Run the following test to check your program's correctness:</p>

<pre><code>python3 gpt149.py part1
</code></pre>

<p>
While running the test, we show results of the pytorch profiler - this information is presented in a table which will show you detailed statistics on all function calls called in the test. The table that is dumped will look like the following:
</p>

<pre><code>-----------------------------  ------------  ------------  ------------  ------------  ------------  ------------  ------------  ------------  
                     Name    Self CPU %      Self CPU   CPU total %     CPU total  CPU time avg       CPU Mem  Self CPU Mem    # of Calls  
-----------------------------  ------------  ------------  ------------  ------------  ------------  ------------  ------------  ------------  
              aten::empty         0.01%      23.000us         0.01%      23.000us       3.286us       5.00 Mb       5.00 Mb             7  
              aten::zeros         0.14%     321.000us         0.18%     408.000us     102.000us       4.50 Mb           4 b             4  
STUDENT - NAIVE ATTENTION        99.56%     229.600ms        99.97%     230.538ms     230.538ms       4.50 Mb      -1.00 Mb             1  
              aten::clone         0.02%      37.000us         0.10%     231.000us     115.500us       1.00 Mb           0 b             2  
            aten::flatten         0.02%      48.000us         0.07%     153.000us      30.600us     512.00 Kb           0 b             5  
         aten::empty_like         0.00%       3.000us         0.00%       8.000us       8.000us     512.00 Kb           0 b             1  
      aten::empty_strided         0.01%      16.000us         0.01%      16.000us      16.000us     512.00 Kb     512.00 Kb             1  
          model_inference         0.02%      38.000us        99.98%     230.578ms     230.578ms     512.00 Kb      -4.00 Mb             1  
              aten::zero_         0.02%      42.000us         0.15%     354.000us      88.500us           0 b           0 b             4  
              aten::fill_         0.14%     312.000us         0.14%     312.000us     156.000us           0 b           0 b             2  
-----------------------------  ------------  ------------  ------------  ------------  ------------  ------------  ------------  ------------  
</code></pre>

<p>
After the table is dumped, we also display two relevant statistics, cpu time (in milliseconds) and mem usage (in bytes). If you implemented your function correctly you should see those two values output like so:
</p>

<pre><code>REFERENCE - NAIVE ATTENTION statistics
cpu time:  230.724ms
mem usage:  4718588 bytes

STUDENT - NAIVE ATTENTION statistics
cpu time:  232.561ms
mem usage:  4718588 bytes
</code></pre>

<p>
If your attention is not producing the correct output, you will see the following message:
</p>

<pre><code>YOUR ATTENTION PRODUCED INCORRECT RESULTS
</code></pre>

<p>
Note that you do not have to exactly match the reference <code>cpu time</code>, as long as you still produce a correct result. You should still be relatively close to the cpu time. We will provide you with a buffer of 15ms with respect to the reference cpu time. So, if you are &lt;= 15ms behind the reference solution then that is fine and you will still get full credit. You are of course encouraged to beat the reference cpu time, and faster speeds will not be penalized.
</p>

<p>
Note that the memory usage value will not change even if you allocate more intermediate variables then we give you. This memory usage is only profiled from the variables passed in as arguments. For each Parts (1-4), we provide you with the minimum amount of variables to produce the correct result. <strong>You can also assume that all the temporary intermediate tensors that we have passed in are initialized to contain zeros.</strong> We do this because we want you to see how the memory usage goes down as operations get fused and there will be writeup questions based on these memory values. Adding any more high memory data structures will most likely only hurt your performance, but you are welcome to try adding additional variables in your <code>module.cpp</code> file and you will not be penalized.
</p>

<p>
You should be sure to test that your function works for different values of N, as this is how we will be grading you on correctness. We have provided a command line argument that works as so:
</p>

<pre><code>python3 gpt149.py part1 -N &lt;val&gt;
</code></pre>

<p>
If you have implemented your attention layer, you can also see the DNN use your attention layer to generate text, optionally changing the model to <code>shakes256</code>, <code>shakes1024</code>, or <code>shakes2048</code> if you wish to output more text:
</p>

<pre><code>python3 gpt149.py part1 --inference -m shakes128
</code></pre>

<p>
Note that you will not be autograded on inference, and this is purely for fun. Please also note that the models <code>shakes1024</code> and <code>shakes2048</code> will not work with the softmax we describe in this writeup due to overflow errors. If you wish to have them work, you must implement the "safe" softmax described in class. This is completely optional as we will always make sure to give you nice values when grading. Parts 1-3 all follow the same grading procedure listed here in this section.
</p>

<h3>What to submit</h3>

<ul>
  <li>Implement <code>myNaiveAttention</code> in <code>module.cpp</code>.</li>
</ul>

<h2>Part 2: Blocked Matrix Multiply and Unfused Softmax (20 Points)</h2>

<p>
  Now that we have our baseline matrix multiply, let's see how we can optimize it. Currently, our matrix multiply behaves as follows:
</p>

<p align="center">
  <img src="https://github.com/stanford-cs149/cs149gpt/blob/main/assets/current_matmul.png" width="40%" height="40%">
</p>

<p>
  Notice how poor the cache behavior of this operation is. For each element of C, we load in multiple cache lines from both A and B. However, something to keep in mind is that the size of these matrices are much bigger than our cache size. Therefore, by the time we want to process our next element of C, we will be reloading cache lines that have been evicted. But what if we reused these cache lines? The main reason that our code is inefficient is because we are processing a single element of C at a time, but what if we processed BLOCK elements at a time? In particular, what if we processed a cache line size of elements?
</p>

<p>
  Your job is to further extend your matrix multiply so that it employs blocking as discussed in 
  <a href="https://gfxcourses.stanford.edu/cs149/fall23/lecture/perfopt2/slide_43">lecture</a>.
  You will decompose the large matrices into smaller cache-sized submatrices. Your multiply will then process the smaller submatrices before evicting them from the cache. The behavior should look like the following:
</p>

<p align="center">
  <img src="https://github.com/stanford-cs149/cs149gpt/blob/main/assets/blocked_matmul.png" width="40%" height="40%">
</p>

<p>
  As a further example, let's say I have 3 NxN matrices and a cache line size of L. I would then break my 3 NxN matrices into (N/L)x(N/L) submatrices. How does this improve my cache utilization?
</p>

<p>
  However, something to keep in mind is that we do not have perfectly square matrices. Our 
  <span style="font-style: italic;">Q</span> and 
  <span style="font-style: italic;">K<sup>T</sup></span> matrices are Nxd and dxN respectively. Keep this in mind as you try to break your matrices into blocks. Furthermore, your tile size will not always divide up N evenly, meaning you will have some "remainder" tiles that are not full of data. In this case, you do not want to iterate over the entire "remainder" tile, but only iterate over a "subtile", which has dimension 
  <code>min(tile_size, N - tileIndex * tileSize)</code>.
</p>

<p>
  Also, keep in mind that as before, the temporary memory you will need is already preallocated for you and passed to the function you need to implement (<code>myUnfusedAttentionBlocked</code>) - you shouldn't have to allocate anything yourself although you will not be penalized for doing so.
</p>

<p><strong>Note that you have two opportunities for blocked matrix multiplication here: QK^t and PV. You should utilize blocked matrix multiply on both in order to achieve the reference speedup.</strong></p>

<h3>Testing:</h3>

<p>Run the following test to check your program's correctness:</p>

<pre><code>python3 gpt149.py part2
</code></pre>

<p>A correct implementation should yield the following output:</p>

<pre><code>REFERENCE - BLOCKED MATMUL + UNFUSED SOFTMAX statistics
cpu time:  156.271ms
mem usage:  4718588 bytes

STUDENT - BLOCKED MATMUL + UNFUSED SOFTMAX statistics
cpu time:  160.891ms
mem usage:  4718588 bytes
</code></pre>

<p>An incorrect implementation will have the output:</p>

<pre><code>YOUR ATTENTION PRODUCED INCORRECT RESULTS
</code></pre>

<p>
  Just as in Part 1, we will autograde the correctness of your function's output and its CPU time. You have the same buffer of &lt;=15ms of the reference solution. If your program is faster you will not be penalized.
</p>

<p>
  You should be sure to test that your function works for different values of N, as this is how we will be grading you on correctness. We have provided a command line argument that works as so:
</p>

<pre><code>python3 gpt149.py part2 -N &lt;val&gt;
</code></pre>

<p>
  You can see the DNN use your attention layer to generate text, optionally changing the model to <code>shakes256</code>, <code>shakes1024</code>, or <code>shakes2048</code> if you wish to output more text:
</p>

<pre><code>python3 gpt149.py part2 --inference -m shakes128
</code></pre>

<p>
  Note that you will not be autograded on inference, and this is purely for fun. Please also note that the models <code>shakes1024</code> and <code>shakes2048</code> will not work with the softmax we describe in this writeup due to overflow errors. If you wish to have them work, you must implement the "safe" softmax described in class. This is completely optional as we will always make sure to give you nice values when grading.
</p>

<h3>What to submit</h3>

<ul>
  <li>Implement <code>myUnfusedAttentionBlocked</code> in <code>module.cpp</code>.</li>
  <li>
    Then, answer the following questions in your writeup:
    <ul>
      <li>
        Share us some data about what tile sizes you tried when N=1024, and what the performance times were for each.
        What was the optimal tile size for your matrix multiplications? Explain why you think this tile size worked best
        for your implementation. There really isn't a wrong answer here, we just want to see that you experimented and tried
        to form conclusions.
      </li>
      <li>
        For a matrix multiply of <span style="font-style: italic;">Q</span> (Nxd) and 
        <span style="font-style: italic;">K<sup>T</sup></span> (dxN), what is the ratio of DRAM accesses in Part 2 versus 
        DRAM acceses in Part 1? (assume 4 byte float primitives, 64 byte cache lines, as well as N and d are very large).
      </li>
    </ul>
  </li>
</ul>

<h2>Part 3: Fused Attention (25 Points)</h2>

<p>
  By now we've seen that multiplying <span style="font-style: italic;">Q * K<sup>T</sup></span> results in a massive NxN matrix.
  Doing the matrix multiplies and softmax in seperate functions requies that we write each row of our NxN matrix, and then do another pass
  over this NxN matrix in the subsequent softmax, and then do a third pass over the softmax'd matrix when multipling it by V. Not only is
  this bad for cache performance, but it is very bad for our program's memory footprint.
</p>

<p>
  Fortunately, we can resolve both issues by "fusing" the calculation, such that we only require one Nx1 temporary vector instead of an NxN temporary matrix.
</p>

<p>
  You can do this by observing the following fact. Once we've calculated a single row of the <span style="font-style: italic;">Q * K<sup>t</sup></span> NxN matrix, we are actually ready to softmax that entire row, and we don't have to calculate the rest of the NxN matrix to do so.
</p>

<p>
  Once that row is softmax'd, we can then immediately multiply the softmax'd row by V to fully compute the first row of our attention output
  (which is of reasonable size: Nxd). In other words, we can calculate just one row of <span style="font-style: italic;">Q * K<sup>t</sup></span>,
  softmax it, then multiply that softmax's row by V. Doing this does not require creating the NxN matrix...it requires creating only one Nx1 size
  intermediate vector to hold the first row of <span style="font-style: italic;">Q*K<sup>t</sup></span> and then its softmax. We can then re-use this
  same Nx1 array to calculate the 2nd row of attention, and then the third, etc. This means that we never materialize the NxN matrix, which is great
  because that matrix is never used again later in the network anyways.
</p>

<h3>Parallelizing with OpenMP</h3>

<p>
  As you may notice, now that we have fused our matrix multiplications and softmax, we made a significant portion of the computation embarrassingly parallel.
  For example, we are able to independently compute batches, heads, and rows of our output matrix.
  This is a perfect opportunity for multi-threading! This time we will be using OpenMP, so you don't have to implement your own threadpools.
  The OpenMP syntax is relatively simple. If you want to parallelize an section of code, it would look like the following:
</p>

<pre><code>#pragma omp parallel for collapse()
    
-- code is here --
</code></pre>

<p>
  You will find <code>#pragma omp parallel for collapse()</code> useful if you find loops directly nested on top of one another and want to parallelize them.
  For example, for a triple perfectly nested loop:
</p>

<pre><code>#pragma omp parallel for collapse(3)

for ()
    for()
        for()
</code></pre>

<p>
  Note: You'd usually want to be careful when writing to a single Nx1 temporary row when using OpenMP, as this is a race condition.
  To work around this, we give you a skeleton of the first three loops (you will need more loops) in which each OpenMP thread gets assigned its own copy
  of the Nx1 temporary array, in a way that avoids race conditions. This local copy of the array is a slice/subset of the temporary memory we allocate for you,
  and pass into the function (<code>myFusedAttention</code>) as an argument. Keep in mind that any variables declared inside the loop(s) you are trying to
  parallelize will be private to each thread.
</p>

<h2>Testing:</h2>

<p>Run the following test to check your program's correctness:</p>

<pre><code>python3 gpt149.py part3
</code></pre>

<p>A correct implementation should yield the following output:</p>

<pre><code>REFERENCE - FUSED ATTENTION statistics
cpu time:  32.361ms
mem usage:  557052 bytes

STUDENT - FUSED ATTENTION statistics
cpu time:  33.209ms
mem usage:  557052 bytes
</code></pre>

<p>An incorrect implementation will have the output:</p>

<pre><code>YOUR ATTENTION PRODUCED INCORRECT RESULTS
</code></pre>

<p>
  Just as in Parts 1 &amp; 2, we will autograde the correctness of your function's output and its CPU time.
  You have the same buffer of &lt;=15ms of the reference solution. If your program is faster you will not be penalized.
</p>

<p>
  You should be sure to test that your function works for different values of N, as this is how we will be grading you on correctness.
  We have provided a command line argument that works as so:
</p>

<pre><code>python3 gpt149.py part3 -N &lt;val&gt;
</code></pre>

<p>
  Now, you can see the DNN use your attention layer to generate text, optionally changing the model to
  <code>shakes256</code>, <code>shakes1024</code>, or <code>shakes2048</code> if you wish to output more text:
</p>

<pre><code>python3 gpt149.py part3 --inference -m shakes128
</code></pre>

<p>
  Note that you will not be autograded on inference, and this is purely for fun.
  Please also note that the models <code>shakes1024</code> and <code>shakes2048</code> will not work with the softmax we describe in this writeup
  due to overflow errors. If you wish to have them work, you must implement the "safe" softmax described in class.
  This is completely optional as we will always make sure to give you nice values when grading.
</p>

<h3>What to submit</h3>

<ul>
  <li>Implement <code>myFusedAttention</code> in <code>module.cpp</code>.</li>
  <li>
    Then, answer the following question in your writeup:
    <ul>
      <li>Why do we use a drastically smaller amount of memory in Part 3 when compared to Parts 1 &amp; 2?</li>
      <li>
        Comment out your <code>#pragma omp ...</code> statement, what happens to your cpu time?
        Record the cpu time in your writeup. Why does fused attention make it easier for us utilize multithreading
        to a much fuller extent when compared to Part 1?
      </li>
    </ul>
  </li>
</ul>

<h2>Part 4 : Putting it all Together - Flash Attention (35 Points)</h2>

<h3>Why Are Matrix Multiply and Softmax Hard to Fuse as Blocks?</h3>
<p>
  The attention formula is very awkward to fuse for a couple reasons. Notice how the formula consists of a matrix multiply, followed by a row-wise calculation from softmax, and concluded with another matrix multiplication. The true thing that makes it difficult from fusing these three operations as blocks is the fact that softmax has to operate on the entire row. So, if we want to bypass this dependency we really have to think outside the box. That is where Flash Attention comes in.
</p>

<h3>Breaking Softmax into Blocks</h3>
<p>
  Let's say that we have a BLOCKSIZE vector, we will denote it as <code>x &in; &Ropf;<sup>B</sup></code>.The softmax of <code>x</code> can be formulated as:
</p>

<p align="center">
  <img src="https://github.com/stanford-cs149/cs149gpt/blob/main/assets/Softmax_decomp1.png" width="55%" height="55%" alt="Softmax decomposition 1"/>
</p>

<p>
  It follows that if we have two BLOCKSIZE vectors, denoted as <code>x &in; &Ropf;<sup>B</sup></code> and <code>y &in; &Ropf;<sup>B</sup></code>, then we can decompose <code>softmax([x y])</code> as:
</p>

<p align="center">
  <img src="https://github.com/stanford-cs149/cs149gpt/blob/main/assets/Softmax_decomp2.png" width="55%" height="55%" alt="Softmax decomposition 2"/>
</p>

<h3>Implement Flash Attention</h3>
<p>
  Your job is to break softmax into blocks so it can be fused with your blocked matrix multiply. Therefore, for each block, you will multiply <code>Q</code> (BLOCKROWSIZE x d) with <code>K<sup>t</sup></code> (d x BLOCKCOLUMNSIZE) to get <code>QK<sup>t</sup></code> (BLOCKROWSIZE x BLOCKCOLUMNSIZE). Then, you will calculate <code>softmax(QK<sup>t</sup>)</code> (BLOCKROWSIZE x BLOCKCOLUMNSIZE) and multiply this with <code>V</code> (BLOCKCOLUMNSIZE x d) to get <code>O</code> (BLOCKROWSIZE x d). Remember, this is an accumulative process just like blocked matrix multiply!
</p>

<p>
  By doing this we can significantly decrease the memory footprint. Rather than having a memory footprint of <code>O(N<sup>2</sup>)</code>, we will be able to reduce this to a linear scaling footprint of <code>O(N)</code>.
</p>

<h3>Flash Attention Pseudocode</h3>
<p>
  The flash attention algorithm shown below, imports blocks of the matrices <code>Q</code>, <code>K</code>, and <code>V</code> into smaller physical tiles. It then computes a local softmax in each tile, and then writes this result tile back to the full output matrix <code>O</code>. For <code>Q</code>, for example, each tile's size is (Br x d), and the tile size for <code>K</code> is (Bc x d). Calculating <code>Br</code> and <code>Bc</code>, as shown in the pseudocode below, requires knowing the size <code>M</code> of your SRAM/cache, which in this case is <code>M = 131072</code> floats. For the purposes of this programming assignment, your program should be able to handle any <code>Br/Bc</code> we give it.
</p>

<p align="center">
  <img src="https://github.com/stanford-cs149/cs149gpt/blob/main/assets/FlashAttentionPseudo.png" width="65%" height="65%" alt="Flash Attention pseudocode"/>
</p>

<h3>Testing:</h3>
<p>Run the following test to check your program's correctness:</p>

<pre><code>python3 gpt149.py part4
</code></pre>

<p><strong>Make sure to test your implementation on different block sizes.</strong> When running this test, the default values of <code>N</code> and <code>d</code> are <code>1024</code> and <code>32</code> respectively. Make sure that your program is able to handle any block size, whether your block size evenly divides into these values of <code>N/d</code> or not. We have given you commandline flags to change the <code>Br</code> and <code>Bc</code> parameters of the attention algorithm. You can do this with the flags <code>-br &lt;value&gt;</code> and <code>-bc &lt;value&gt;</code>. The default values for each are <code>256</code>. For example, if I wanted to change <code>Br</code> to <code>128</code> and <code>Bc</code> to <code>512</code> I would run:</p>

<pre><code>python3 gpt149.py part4 -br 128 -bc 512
</code></pre>

<p>A correct implementation should yield the following output:</p>

<pre><code>REFERENCE - FLASH ATTENTION statistics
cpu time:  435.709ms
mem usage:  524284 bytes

STUDENT - FLASH ATTENTION statistics
cpu time:  435.937ms
mem usage:  524284 bytes
</code></pre>

<p>An incorrect implementation will have the output:</p>

<pre><code>YOUR ATTENTION PRODUCED INCORRECT RESULTS
</code></pre>

<p>Notice that the cpu speed is actually lower than Part 3. Why is this the case? You will answer this question in your writeup below.</p>

<p>
  You should be sure to test that your function works for different values of <code>N</code>, as this is how we will be grading you on correctness. You should test different <code>N</code>s as well as different <code>block_sizes</code>. Please note that the reference solution runs first, so if the reference solution fails then you do not have to worry about that combination of <code>N/Br/Bc</code>. To change the values of <code>N</code>, <code>Br</code>, and <code>Bc</code>:
</p>

<pre><code>python3 gpt149.py part4 -N &lt;val&gt; -br &lt;val&gt; -bc &lt;val&gt;
</code></pre>

<p>
  <strong>For this problem only</strong>, you will be graded solely on correctness and not performance. The grading consists on an automated check that your algorithm produced the correct output and a manual check that you followed the pseudocode from above. If you ran the command <code>python3 gpt149.py part4</code> and you saw the output above that is associated with a correct implementation and DID NOT see: <code>YOUR ATTENTION PRODUCED INCORRECT RESULTS</code>, then you passed the autograded portion. For the correctness check, we also reserve the right to change the values of <code>N</code>, <code>Br</code>, and <code>Bc</code>. If you followed the pseudocode from the image above, then you will pass the manual check.
</p>

<p>
  Now, you can see the DNN use your attention layer to generate text, optionally changing the model to <code>shakes256</code>, <code>shakes1024</code>, or <code>shakes2048</code> if you wish to output more text:
</p>

<pre><code>python3 gpt149.py part4 --inference -m shakes128
</code></pre>

<p>
  Note that you will not be autograded on inference, and this is purely for fun. Please also note that the models <code>shakes1024</code> and <code>shakes2048</code> will not work with the softmax we describe in this writeup due to overflow errors. If you wish to have them work, you must implement the "safe" softmax described in class. This is completely optional as we will always make sure to give you nice values when grading.
</p>

<h3>What to submit</h3>
<ul>
  <li>Implement <code>myFlashAttention</code> in <code>module.cpp</code>.</li>
  <li>Then, answer the following question in your writeup:
    <ul>
      <li>How does the memory usage of Part 4 compare to that of the previous parts? Why is this the case?</li>
      <li>
        Notice that the performance of Part 4 is slower than that of the previous parts. Have we fully optimized Part 4? What other performance improvements can be done? Please list them and describe why they would increase performance.
      </li>
    </ul>
  </li>
</ul>

<h2>Extra Credit: Optimize Further (12 Total Points - 3 Points Per Part)</h2>

<h3>Vectorize with ISPC Intrinsics</h3>
<p>
  You may notice that there are many looped-based nondivergent floating point operations. This is a great place to use vector intrinsics! We have provided ISPC support for you to write you own vectorized functions for things such as matrix multiplication and row sum. The repo contains a file titled <code>module.ispc</code>. Feel free to write your own ISPC functions in here, and compile them with the command:
</p>

<pre><code>ispc -O3 --target=avx2-i32x8 --arch=x86-64 --pic module.ispc -h module_ispc.h -o module_ispc.o
</code></pre>

<p>
  To enable them in your <code>module.cpp</code> file, all you need to simply uncomment the following two lines at the top of the file:
</p>

<pre><code>#include "module_ispc.h"
using namespace ispc;
</code></pre>

<h3>Write-Up Question</h3>
<ul>
  <li>Please record your speedups with vectorization and your implementations in <code>writeup.pdf</code>.</li>
</ul>

<h2>Point BreakDown: (100 Total Points + 12 Possible Extra Credit)</h2>
<ul>
  <li>Implement <code>fourDimRead</code>: 1.5 Points</li>
  <li>Implement <code>fourDimWrite</code>: 1.5 Points</li>
  <li>Implement <code>myNaiveAttention</code>: 10 Points</li>
  <li>Implement <code>myUnfusedAttentionBlocked</code>: 20 Points</li>
  <li>Implement <code>myFusedAttention</code>: 25 Points</li>
  <li>Implement <code>myFlashAttention</code>: 35 Points</li>
  <li>Answer Writeup Questions: 7 Points
    <ul>
      <li>1 Warm-Up Question</li>
      <li>2 Part 2 Questions</li>
      <li>2 Part 3 Questions</li>
      <li>2 Part 4 Questions</li>
    </ul>
  </li>
  <li>Extra Credit: Vectorize Parts 1-4: 3 Points Per Part</li>
</ul>

<h2>Hand-in Instructions</h2>
<p>
  Please submit your work using <a href="https://www.gradescope.com/">Gradescope</a>. If you are working with a partner please remember to tag your partner on gradescope.
</p>

<p>
  Please submit your writeup questions in a file <code>writeup.pdf</code>. REMEMBER to map the pages to questions on gradescope. If you did the extra credit, please state so at the end of your writeup as we will manually run these. In addition, please record the performance numbers we should expect for each part that you sped up using vectorization.
</p>

<ul>
  <li>Please submit the following files to Assignment 4 (Code):
    <ul>
      <li><code>module.cpp</code></li>
      <li><code>module.ispc</code> (if you attempted the extra credit)</li>
    </ul>
  </li>
  <li>Please submit your writeup in a file called <code>writeup.pdf</code> to Assignment 4 (Write-Up).</li>
</ul>

</main>
</body></html>